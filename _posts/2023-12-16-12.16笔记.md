---
title:12.16笔记

---

# 12-9

Collections的copy方法，这个被放入的集合的大小要比放入的size大

所以利用aslist  Object类型数组实现

```
public void test52(){
    List list = Arrays.asList(1, 42, 325, 2, 325, 25235, 255, 53, 5, 435, 346, 66, 4, 7);
    List arrayList = Arrays.asList(new Object[list.size()]);
    Collections.copy(arrayList,list);
    System.out.println(arrayList);
}
```

一开始就确定集合的初始化，貌似只有Arrays的方法了

- 这个接口和方法

```
        Iterator iterator1 = entrySet.iterator();
        while (iterator1.hasNext()){
//            System.out.println(iterator1.next());
            Map.Entry a = (Map.Entry) iterator1.next();
            System.out.println(a.getKey()+"\t"+a.getValue());
        }
```

- 一个不错的terrmap的使用场景

- 社招偏实践，校招偏理论

- final修饰map，map依然可以加数据

修饰只是让地址不能变，这里地址没变改了数据

- 接口和抽象类不能实例化

- ```
	③ 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。
	```

这里order用了泛型，方法返回的集合才有接口，难道真的是不用就一直不用？

```
Order<String> order1 = new Order<>();

Integer[] arr = new Integer[]{1,2,3,4,5};
ArrayList<Integer> list = order1.copyFromArrayToList(arr);
for(Integer i : list){
    System.out.println(i);
}
```

- 多态的转型

总是不小心搞错，能不能向下类型转换，就是看new的真是是new的什么类型，自能强转为new的类型，极其父类

