---
title ： 12.8笔记
---

# 12-8

只能理解为entryset放回一个装着hashmap类型元素的集合，然后用itertor方法，得到，entry类型，就可以用接口强转

在Java 8及之前的版本中，`HashMap`使用的是链表来存储键值对。而在Java 8之后的版本中，`HashMap`在发生Hash冲突时会采用链表和红黑树两种结构来存储键值对，以提高查询效率。因此，`HashMap.Node`是Java 8及之前版本中使用的内部类，用于表示链表结构中的节点。

在Java 8及之前的版本中，如果你想要获取`HashMap`中的键值对，可以通过迭代器遍历`entrySet()`方法返回的集合，然后将迭代器返回的对象强制转换为`HashMap.Node`类型，以便直接访问键值对的key和value属性。

但是，在Java 8之后的版本中，`HashMap.Node`被替换为了`Node`接口，并且`getNode()`方法已被废弃。取而代之的是，`HashMap`实现了`Map.Entry`接口，并且提供了新的API来获取键值对。

因此，在Java 8及之后的版本中，建议使用`entrySet()`方法返回的集合或`forEach()`方法来遍历键值对，以及使用`getKey()`和`getValue()`方法来获取键值对的key和value属性。不过如果你确实需要在Java 8及之前的版本中使用`HashMap.Node`类型，那么强制转换为该类型应该是可行的，前提是你知道这些键值对是以链表结构存储的。

- treeset/map比较大小

结构都是红黑树的，并且比较大小的不再是hashcode和equal了而是看比较器，要是一样，set就不会进去，map是覆盖

- 增强for循环

for(元素的数据类型 局部变量 : Collection集合或数组){ 
  	//操作局部变量的输出操作
}

这个参数一般都是，set，list，或者是entrySet返回的set的键字对，不敲代码还真发现不了

- 耦合度（感觉就是关联性）

```
数据和代码耦合度高；如果修改的话，需要重写的编译代码、打包发布，繁琐
        //数据
//        String name = "Tom";
//        String password = "abc123";

        //代码：用于操作name,password
        //...

        //方式2：将数据封装到具体的配置文件中，在程序中读取配置文件中的信息。实现了
        //数据和代码的解耦；由于我们没有修改代码，就省去了重新编译和打包的过程。
```
