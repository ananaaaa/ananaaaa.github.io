---
layout:article
title:"经验库"
---

### list

#### 12-2

- 数组初始化

对于一维数组，常用的初始化方法有以下几种：

1. 直接初始化：通过指定每个元素的值来初始化数组

	```java
	int[] arr = {1, 2, 3, 4, 5};
	```

2. 动态初始化：通过指定数组长度来初始化数组，数组中的每个元素自动被赋为默认值

	```java
	int[] arr = new int[5];
	```

3. 静态初始化：通过指定数组长度和每个元素的值来初始化数组

	```java
	int[] arr = new int[]{1, 2, 3, 4, 5};
	```

对于二维数组，常用的初始化方法有以下几种：

1. 直接初始化：通过指定每个元素的值来初始化数组

	```java
	int[][] arr = {{1, 2, 3}, {4, 5, 6}};
	```

2. 动态初始化：通过指定数组长度来初始化数组，数组中的每个元素自动被赋为默认值

	```java
	int[][] arr = new int[2][3];
	```

3. 静态初始化：通过指定数组长度和每个元素的值来初始化数组

	```java
	int[][] arr = new int[][]{{1, 2, 3}, {4, 5, 6}};
	```

需要注意的是，在二维数组的静态初始化中，可以省略第二维的长度，如下所示：

```java
int[][] arr = {{1, 2, 3}, {4, 5, 6}};
```

这样做的好处是，可以让Java编译器自动推断第二维的长度。

-  常用apl细节


Math方法的pow返回double类型，所以容易范围溢出

包装类有直接进制转换的方法



#### 12-4

- 首先是包装类享元的设计思想

是的，Java中的Integer、Byte、Short、Character、Long这五种包装类型的对象，在内存中会预先创建一定范围的常量池，以供重复使用。这个范围是 -128 到 127，也就是说，如果创建一个数值在该范围内的 Integer 对象，那么其实是从常量池中获取一个已存在的对象的引用，而不是重新创建一个对象。

这个优化的目的是为了减少短时间内创建大量小数值对象而导致的内存开销和垃圾回收压力。因此，对于数值在 -128 到 127 范围内的 Integer 对象，可以直接使用 == 进行比较，而不需要使用 equals 方法。

需要注意的是，这个优化只针对自动装箱操作（即基本数据类型到包装类型的转换），对于手动创建 Integer 对象的方式，这个优化是不适用的。例如，使用 new Integer(100) 创建的 Integer 对象，每次都会创建一个新的对象，而不会从常量池中获取已有对象的引用。

	Integer i1 = 128;
		Integer i2 = 128;
		int i3 = 128;
		int i4 = 128;
		System.out.println(i1 == i2);//false，比较地址，128超过Integer缓存对象
		System.out.println(i3 == i4);//true，比较数据值
		System.out.println(i1 == i3);//true，i1自动拆箱按照基本数据类型比较
	    //包装类对象与基本数据类型进行比较时，就会把包装类对象自动拆箱，按照基本数据类型的规则进行比较

拆包肯定更快啊

Java中的Integer、Byte、Short、Character、Long这五种包装类型的对象，Double没有



- 重写的equal方法

```
     public boolean equals(Object o) {
        System.out.println("Person fangfa");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name);
    }


```

这段代码是一个重写了 Object 类的 equals 方法的 Person 类的实现，主要作用是判断两个 Person 对象是否相等。

首先，代码中的第一行输出语句只是为了验证 equals 方法被调用的次数，不影响方法本身的实现。

接下来，代码使用 this == o 判断两个对象是否是同一个引用，如果是，则直接返回 true。这是一个优化措施，在比较对象相等性时，如果对象是同一个引用，其它的比较操作都可以省略，直接返回 true。

然后，代码对传入的对象进行类型检查，使用 o.getClass() 方法判断 o 是否是 Person 类型的对象，如果不是，则返回 false。这是因为在比较两个对象是否相等时，如果两个对象的类型不同，则它们一定是不相等的。如果 o 是 null，则直接返回false，因为一个对象跟null肯定不等。

接着，代码将 o 强制转换为 Person 类型的对象，如果转换失败，则会抛出 ClassCastException 异常。如果转换成功，则继续进行属性比较。

最后，代码使用 age == person.age 判断两个 Person 对象的年龄是否相等，使用 Objects.equals(name, [person.name](http://person.name/)) 来判断两个 Person 对象的姓名是否相等。其中，Objects.equals 方法是 Java 7 中引入的静态方法，用于比较两个对象是否相等，它会先检查两个对象是否为同一个引用，如果是同一个引用则直接返回 true；否则，会调用第一个对象的 equals 方法来比较内容是否相等。这里使用 Objects.equals 方法来比较 name 属性是一种良好的做法，因为它考虑了可能出现的空指针情况，并且会正确地调用 name 对象的 equals 方法来比较内容是否相等



- 比较的源码

```
public void test04(){
    Collection a = new ArrayList();
    Collection te = new ArrayList();
    a.add(new test00((ArrayList) te));
    System.out.println(a.contains(new test00((ArrayList) te)));
}
```

对你这里是没有了重写的equal引用数据类型，你用了集合，但是集合本身就是应用数据类型啊，你要确保它的内容一样，不就要地址一样，这样都轮不到后面的你想的调用这些没有重写equals方法的数据类型去调用父类的equals方法，递归，而是在前面就地址相同了，靠靠，集合重写了equal方法，ai完全的猪





#### 12-6

```
3. 向Collection中添加元素的要求：
  要求元素所属的类一定要重写equals()!
```

```
原因：
因为Collection中的相关方法（比如：contains() / remove()）在使用时，要调用元素所在类的equals()。
```

数组方法少，长度确定不易更改，不能随意的进行增删改查

哦哦哦，集合没有索引所以用迭代器和增强for循环遍历   list是增强动态数组有索引，所以方法就多一点有了查和改

- 集合

Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合，看源码明明就是返回一个new 的ArrayList类型





```
    arrayList.add(student);
}

System.out.println("遍历信息");
for (Object s : arrayList){
    System.out.println(s);
}
```

这里调用增强for循环还是object ，因为add默认你加的就是obj类型的





- set的无序性

哈希值是通过计算加入进来的各个对象的元素的哈希值得来的，以为重写了方法，调用的不是object的方法，然后就是可能算法简单或者加强除余算法导致哈希值一样，再equals方法



- set集合，add和remove都要看hash值，你要是中途改了就找不到，删不了



```
3. 向Collection中添加元素的要求：
  要求元素所属的类一定要重写equals()!

原因：
因为Collection中的相关方法（比如：contains() / remove()）在使用时，要调用元素所在类的equals()。
```



#### 12-8



只能理解为entryset放回一个装着hashmap类型元素的集合，然后用itertor方法，得到，entry类型，就可以用接口强转

在Java 8及之前的版本中，`HashMap`使用的是链表来存储键值对。而在Java 8之后的版本中，`HashMap`在发生Hash冲突时会采用链表和红黑树两种结构来存储键值对，以提高查询效率。因此，`HashMap.Node`是Java 8及之前版本中使用的内部类，用于表示链表结构中的节点。

在Java 8及之前的版本中，如果你想要获取`HashMap`中的键值对，可以通过迭代器遍历`entrySet()`方法返回的集合，然后将迭代器返回的对象强制转换为`HashMap.Node`类型，以便直接访问键值对的key和value属性。

但是，在Java 8之后的版本中，`HashMap.Node`被替换为了`Node`接口，并且`getNode()`方法已被废弃。取而代之的是，`HashMap`实现了`Map.Entry`接口，并且提供了新的API来获取键值对。

因此，在Java 8及之后的版本中，建议使用`entrySet()`方法返回的集合或`forEach()`方法来遍历键值对，以及使用`getKey()`和`getValue()`方法来获取键值对的key和value属性。不过如果你确实需要在Java 8及之前的版本中使用`HashMap.Node`类型，那么强制转换为该类型应该是可行的，前提是你知道这些键值对是以链表结构存储的。



- treeset/map比较大小

结构都是红黑树的，并且比较大小的不再是hashcode和equal了而是看比较器，要是一样，set就不会进去，map是覆盖

- 增强for循环

for(元素的数据类型 局部变量 : Collection集合或数组){ 
  	//操作局部变量的输出操作
}

这个参数一般都是，set，list，或者是entrySet返回的set的键字对，不敲代码还真发现不了

- 耦合度（感觉就是关联性）

```
数据和代码耦合度高；如果修改的话，需要重写的编译代码、打包发布，繁琐
        //数据
//        String name = "Tom";
//        String password = "abc123";

        //代码：用于操作name,password
        //...

        //方式2：将数据封装到具体的配置文件中，在程序中读取配置文件中的信息。实现了
        //数据和代码的解耦；由于我们没有修改代码，就省去了重新编译和打包的过程。
```





#### 12-9

Collections的copy方法，这个被放入的集合的大小要比放入的size大

所以利用aslist  Object类型数组实现

```
public void test52(){
    List list = Arrays.asList(1, 42, 325, 2, 325, 25235, 255, 53, 5, 435, 346, 66, 4, 7);
    List arrayList = Arrays.asList(new Object[list.size()]);
    Collections.copy(arrayList,list);
    System.out.println(arrayList);
}
```

一开始就确定集合的初始化，貌似只有Arrays的方法了



- 这个接口和方法

```
        Iterator iterator1 = entrySet.iterator();
        while (iterator1.hasNext()){
//            System.out.println(iterator1.next());
            Map.Entry a = (Map.Entry) iterator1.next();
            System.out.println(a.getKey()+"\t"+a.getValue());
        }
```



- 一个不错的terrmap的使用场景



- 社招偏实践，校招偏理论



- final修饰map，map依然可以加数据

修饰只是让地址不能变，这里地址没变改了数据

- 接口和抽象类不能实例化

- ```
	③ 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。
	```

这里order用了泛型，方法返回的集合才有接口，难道真的是不用就一直不用？

```
Order<String> order1 = new Order<>();

Integer[] arr = new Integer[]{1,2,3,4,5};
ArrayList<Integer> list = order1.copyFromArrayToList(arr);
for(Integer i : list){
    System.out.println(i);
}
```



#### 12-13

- 多态的转型

总是不小心搞错，能不能向下类型转换，就是看new的真是是new的什么类型，自能强转为new的类型，极其父类



#### 12-15

- 泛型是一种限制（通用性变差）

所以泛型符号里面是没有继承关系的，否则要是继承能多态，那泛型限制类型发作用不就不自洽

- IO流

```
// "\" 是转移字符 路径分隔符也是\  so \\
//window 的路径分隔符是\
//linux 的是/
```

尽量用方法，这里就是构造器来拼接



#### 12-18

- listFile（）

```
//返回null的情况，是一个文件  调用的路径不存在时  需要权限的文件夹
//返回0 空的文件夹
//会返回隐藏文件
//返回的是一个数组，
```

- IO流24暂缓，因为有方法引用，等知识点

