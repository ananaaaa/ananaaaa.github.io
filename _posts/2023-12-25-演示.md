---
layout: article
title: 12.4演示的笔记
---

# 12-4

- 首先是包装类享元的设计思想

是的，Java中的Integer、Byte、Short、Character、Long这五种包装类型的对象，在内存中会预先创建一定范围的常量池，以供重复使用。这个范围是 -128 到 127，也就是说，如果创建一个数值在该范围内的 Integer 对象，那么其实是从常量池中获取一个已存在的对象的引用，而不是重新创建一个对象。

这个优化的目的是为了减少短时间内创建大量小数值对象而导致的内存开销和垃圾回收压力。因此，对于数值在 -128 到 127 范围内的 Integer 对象，可以直接使用 == 进行比较，而不需要使用 equals 方法。

需要注意的是，这个优化只针对自动装箱操作（即基本数据类型到包装类型的转换），对于手动创建 Integer 对象的方式，这个优化是不适用的。例如，使用 new Integer(100) 创建的 Integer 对象，每次都会创建一个新的对象，而不会从常量池中获取已有对象的引用。

	Integer i1 = 128;
		Integer i2 = 128;
		int i3 = 128;
		int i4 = 128;
		System.out.println(i1 == i2);//false，比较地址，128超过Integer缓存对象
		System.out.println(i3 == i4);//true，比较数据值
		System.out.println(i1 == i3);//true，i1自动拆箱按照基本数据类型比较
	    //包装类对象与基本数据类型进行比较时，就会把包装类对象自动拆箱，按照基本数据类型的规则进行比较

拆包肯定更快啊

Java中的Integer、Byte、Short、Character、Long这五种包装类型的对象，Double没有



- 重写的equal方法

```
     public boolean equals(Object o) {
        System.out.println("Person fangfa");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name);
    }


```

这段代码是一个重写了 Object 类的 equals 方法的 Person 类的实现，主要作用是判断两个 Person 对象是否相等。

首先，代码中的第一行输出语句只是为了验证 equals 方法被调用的次数，不影响方法本身的实现。

接下来，代码使用 this == o 判断两个对象是否是同一个引用，如果是，则直接返回 true。这是一个优化措施，在比较对象相等性时，如果对象是同一个引用，其它的比较操作都可以省略，直接返回 true。

然后，代码对传入的对象进行类型检查，使用 o.getClass() 方法判断 o 是否是 Person 类型的对象，如果不是，则返回 false。这是因为在比较两个对象是否相等时，如果两个对象的类型不同，则它们一定是不相等的。如果 o 是 null，则直接返回false，因为一个对象跟null肯定不等。

接着，代码将 o 强制转换为 Person 类型的对象，如果转换失败，则会抛出 ClassCastException 异常。如果转换成功，则继续进行属性比较。

最后，代码使用 age == person.age 判断两个 Person 对象的年龄是否相等，使用 Objects.equals(name, [person.name](http://person.name/)) 来判断两个 Person 对象的姓名是否相等。其中，Objects.equals 方法是 Java 7 中引入的静态方法，用于比较两个对象是否相等，它会先检查两个对象是否为同一个引用，如果是同一个引用则直接返回 true；否则，会调用第一个对象的 equals 方法来比较内容是否相等。这里使用 Objects.equals 方法来比较 name 属性是一种良好的做法，因为它考虑了可能出现的空指针情况，并且会正确地调用 name 对象的 equals 方法来比较内容是否相等



- 比较的源码

```
public void test04(){
    Collection a = new ArrayList();
    Collection te = new ArrayList();
    a.add(new test00((ArrayList) te));
    System.out.println(a.contains(new test00((ArrayList) te)));
}
```

对你这里是没有了重写的equal引用数据类型，你用了集合，但是集合本身就是应用数据类型啊，你要确保它的内容一样，不就要地址一样，这样都轮不到后面的你想的调用这些没有重写equals方法的数据类型去调用父类的equals方法，递归，而是在前面就地址相同了，靠靠，集合重写了equal方法，ai完全的猪



